# generated by datamodel-codegen:
#   filename:  StudyConfigSchema.json
#   timestamp: 2025-01-30T21:57:22+00:00

from __future__ import annotations

import warnings
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, TypedDict, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel

warnings.filterwarnings("ignore", module="pydantic")


class Answer(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    acceptableHigh: Optional[float] = Field(
        None,
        description='The acceptable high value for the answer. This is used to define a range of acceptable answers.',
    )
    acceptableLow: Optional[float] = Field(
        None,
        description='The acceptable low value for the answer. This is used to define a range of acceptable answers.',
    )
    answer: Any = Field(..., description='The correct answer to the question.')
    id: str = Field(
        ...,
        description='The id of the answer. This is used to identify the answer in the data file.',
    )  # End of class


class AnswerType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    acceptableHigh: Optional[float] = Field(
        None,
        description='The acceptable high value for the answer. This is used to define a range of acceptable answers.',
    )
    acceptableLow: Optional[float] = Field(
        None,
        description='The acceptable low value for the answer. This is used to define a range of acceptable answers.',
    )
    answer: Any = Field(..., description='The correct answer to the question.')
    id: str = Field(
        ...,
        description='The id of the answer. This is used to identify the answer in the data file.',
    )


class Type(Enum):
    markdown = 'markdown'
    react_component = 'react-component'
    image = 'image'
    website = 'website'
    questionnaire = 'questionnaire'
    vega = 'vega'


class Order(Enum):
    random = 'random'
    latinSquare = 'latinSquare'
    fixed = 'fixed'


class Condition(Enum):
    numCorrect = 'numCorrect'
    numIncorrect = 'numIncorrect'


warnings.filterwarnings("ignore", module="pydantic")


class ComponentBlockCondition(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    check: Literal['block'] = Field(..., description="The check we'll perform.")
    condition: Condition = Field(..., description='The condition to check.')
    to: str = Field(..., description='The id of the component or block to skip to')
    value: float = Field(
        ..., description='The number of correct or incorrect responses to check for.'
    )  # End of class


class ComponentBlockConditionType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    check: Literal['block'] = Field(..., description="The check we'll perform.")
    condition: Condition = Field(..., description='The condition to check.')
    to: str = Field(..., description='The id of the component or block to skip to')
    value: float = Field(
        ..., description='The number of correct or incorrect responses to check for.'
    )


warnings.filterwarnings("ignore", module="pydantic")


class DeterministicInterruption(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    components: List[str] = Field(
        ...,
        description='The components that are included in the interruption. These reference components in the StudyConfig.components section of the config.',
    )
    firstLocation: float = Field(
        ...,
        description='The Location of the first instance of the interruption. If this is set to 2, the interruption will be shown after the second component (inserted at index 2).',
    )
    spacing: float = Field(
        ..., description='The number of components between breaks.'
    )  # End of class


class DeterministicInterruptionType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    components: List[str] = Field(
        ...,
        description='The components that are included in the interruption. These reference components in the StudyConfig.components section of the config.',
    )
    firstLocation: float = Field(
        ...,
        description='The Location of the first instance of the interruption. If this is set to 2, the interruption will be shown after the second component (inserted at index 2).',
    )
    spacing: float = Field(..., description='The number of components between breaks.')


warnings.filterwarnings("ignore", module="pydantic")


class IndividualComponentAllResponsesCondition(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    check: Literal['responses'] = Field(..., description="The check we'll perform.")
    name: str = Field(..., description='The name of the component to check.')
    to: str = Field(
        ..., description='The id of the component or block to skip to'
    )  # End of class


class IndividualComponentAllResponsesConditionType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    check: Literal['responses'] = Field(..., description="The check we'll perform.")
    name: str = Field(..., description='The name of the component to check.')
    to: str = Field(..., description='The id of the component or block to skip to')


class Comparison(Enum):
    equal = 'equal'
    notEqual = 'notEqual'


warnings.filterwarnings("ignore", module="pydantic")


class IndividualComponentSingleResponseCondition(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    check: Literal['response'] = Field(..., description="The check we'll perform.")
    comparison: Comparison = Field(..., description='The comparison to use.')
    name: str = Field(..., description='The name of the component to check.')
    responseId: str = Field(..., description='The response id to check.')
    to: str = Field(..., description='The id of the component or block to skip to')
    value: Union[str, float] = Field(
        ..., description='The value to check.'
    )  # End of class


class IndividualComponentSingleResponseConditionType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    check: Literal['response'] = Field(..., description="The check we'll perform.")
    comparison: Comparison = Field(..., description='The comparison to use.')
    name: str = Field(..., description='The name of the component to check.')
    responseId: str = Field(..., description='The response id to check.')
    to: str = Field(..., description='The id of the component or block to skip to')
    value: Union[str, float] = Field(..., description='The value to check.')


class Type2(Enum):
    matrix_radio = 'matrix-radio'
    matrix_checkbox = 'matrix-checkbox'


warnings.filterwarnings("ignore", module="pydantic")


class NumberOption(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    label: str = Field(..., description='The label displayed to participants.')
    value: float = Field(
        ..., description="The value stored in the participant's data."
    )  # End of class


class NumberOptionType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    label: str = Field(..., description='The label displayed to participants.')
    value: float = Field(..., description="The value stored in the participant's data.")


warnings.filterwarnings("ignore", module="pydantic")


class RandomInterruption(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    components: List[str] = Field(
        ...,
        description='The components that are included in the interruption. These reference components in the StudyConfig.components section of the config.',
    )
    numInterruptions: float = Field(
        ..., description='The number of times the interruption will be randomly added'
    )
    spacing: Literal['random'] = Field(
        ...,
        description='If spacing is set to random, reVISit will add interruptions randomly. These interruptions will not ever be displayed as the first component in the block.',
    )  # End of class


class RandomInterruptionType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    components: List[str] = Field(
        ...,
        description='The components that are included in the interruption. These reference components in the StudyConfig.components section of the config.',
    )
    numInterruptions: float = Field(
        ..., description='The number of times the interruption will be randomly added'
    )
    spacing: Literal['random'] = Field(
        ...,
        description='If spacing is set to random, reVISit will add interruptions randomly. These interruptions will not ever be displayed as the first component in the block.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class RepeatedComponentBlockCondition(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    check: Literal['repeatedComponent'] = Field(
        ..., description="The check we'll perform."
    )
    condition: Condition = Field(..., description='The condition to check.')
    name: str = Field(
        ...,
        description='The name of the repeated component to check (e.g. attentionCheck).',
    )
    to: str = Field(..., description='The id of the component or block to skip to')
    value: float = Field(
        ..., description='The number of correct or incorrect responses to check for.'
    )  # End of class


class RepeatedComponentBlockConditionType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    check: Literal['repeatedComponent'] = Field(
        ..., description="The check we'll perform."
    )
    condition: Condition = Field(..., description='The condition to check.')
    name: str = Field(
        ...,
        description='The name of the repeated component to check (e.g. attentionCheck).',
    )
    to: str = Field(..., description='The id of the component or block to skip to')
    value: float = Field(
        ..., description='The number of correct or incorrect responses to check for.'
    )


class ResponseBlockLocation(Enum):
    sidebar = 'sidebar'
    aboveStimulus = 'aboveStimulus'
    belowStimulus = 'belowStimulus'


warnings.filterwarnings("ignore", module="pydantic")


class ShortTextResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    placeholder: Optional[str] = Field(
        None, description='The placeholder text that is displayed in the input.'
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['shortText']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )  # End of class


class ShortTextResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    placeholder: Optional[str] = Field(
        None, description='The placeholder text that is displayed in the input.'
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['shortText']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )


class SkipConditions(
    RootModel[
        List[
            Union[
                IndividualComponentSingleResponseCondition,
                IndividualComponentAllResponsesCondition,
                ComponentBlockCondition,
                RepeatedComponentBlockCondition,
            ]
        ]
    ]
):
    root: List[
        Union[
            IndividualComponentSingleResponseCondition,
            IndividualComponentAllResponsesCondition,
            ComponentBlockCondition,
            RepeatedComponentBlockCondition,
        ]
    ] = Field(
        ...,
        description='The SkipConditions interface is used to define skip conditions. This is used to skip to a different component/block based on the response to a component or based on the number of correct/incorrect responses in a block. Skip conditions work recursively: if you have a nested block, the parent blocks\' skip conditions will be considered when computing the skip logic.\n\nSkip conditions are evaluated in the order they are defined in the array. If a condition is met, the participant will be redirected to the component or block specified in the `"to"` property. If no conditions are met, the participant will continue to the next component in the sequence.\n\nSkip conditions allow you to jump to a different component or block. If you intend to skip to a block, you should specify a block id in the sequence. If you intend to skip to a component, you should specify a component id. Skipping backwards is not supported. Skipping to a repeated component will skip to the first instance of the component after the component that triggered the skip.\n\nPlease see the interface definitions for more specific information on the different types of skip conditions.',
    )


# End of class


class SkipConditionsType(TypedDict):
    root: List[
        Union[
            IndividualComponentSingleResponseCondition,
            IndividualComponentAllResponsesCondition,
            ComponentBlockCondition,
            RepeatedComponentBlockCondition,
        ]
    ] = Field(
        ...,
        description='The SkipConditions interface is used to define skip conditions. This is used to skip to a different component/block based on the response to a component or based on the number of correct/incorrect responses in a block. Skip conditions work recursively: if you have a nested block, the parent blocks\' skip conditions will be considered when computing the skip logic.\n\nSkip conditions are evaluated in the order they are defined in the array. If a condition is met, the participant will be redirected to the component or block specified in the `"to"` property. If no conditions are met, the participant will continue to the next component in the sequence.\n\nSkip conditions allow you to jump to a different component or block. If you intend to skip to a block, you should specify a block id in the sequence. If you intend to skip to a component, you should specify a component id. Skipping backwards is not supported. Skipping to a repeated component will skip to the first instance of the component after the component that triggered the skip.\n\nPlease see the interface definitions for more specific information on the different types of skip conditions.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class SliderResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    options: List[NumberOption] = Field(
        ...,
        description='This defines the steps in the slider and the extent of the slider as an array of objects that have a label and a value.',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    snap: Optional[bool] = Field(
        None,
        description='Whether the slider should snap between values. Defaults to false. Slider snapping disables the label above the handle.',
    )
    startingValue: Optional[float] = Field(
        None,
        description='The starting value of the slider. Defaults to the minimum value.',
    )
    type: Literal['slider']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )  # End of class


class SliderResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    options: List[NumberOption] = Field(
        ...,
        description='This defines the steps in the slider and the extent of the slider as an array of objects that have a label and a value.',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    snap: Optional[bool] = Field(
        None,
        description='Whether the slider should snap between values. Defaults to false. Slider snapping disables the label above the handle.',
    )
    startingValue: Optional[float] = Field(
        None,
        description='The starting value of the slider. Defaults to the minimum value.',
    )
    type: Literal['slider']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class StringOption(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    label: str = Field(..., description='The label displayed to participants.')
    value: str = Field(
        ..., description="The value stored in the participant's data."
    )  # End of class


class StringOptionType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    label: str = Field(..., description='The label displayed to participants.')
    value: str = Field(..., description="The value stored in the participant's data.")


warnings.filterwarnings("ignore", module="pydantic")


class StudyMetadata(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    authors: List[str] = Field(..., description='The authors of your study.')
    date: str = Field(
        ..., description='The date of your study, may be useful for the researcher.'
    )
    description: str = Field(
        ..., description='The description of your study, shown on the landing page.'
    )
    organizations: List[str] = Field(
        ..., description='The organizations that are associated with your study.'
    )
    title: str = Field(
        ..., description='The title of your study, shown on the landing page.'
    )
    version: str = Field(
        ...,
        description='The version of your study. When you change a configuration file after a study has already been distributed to participants, you can change the version number so that the participants who see this new configuration file can be identified.',
    )  # End of class


class StudyMetadataType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    authors: List[str] = Field(..., description='The authors of your study.')
    date: str = Field(
        ..., description='The date of your study, may be useful for the researcher.'
    )
    description: str = Field(
        ..., description='The description of your study, shown on the landing page.'
    )
    organizations: List[str] = Field(
        ..., description='The organizations that are associated with your study.'
    )
    title: str = Field(
        ..., description='The title of your study, shown on the landing page.'
    )
    version: str = Field(
        ...,
        description='The version of your study. When you change a configuration file after a study has already been distributed to participants, you can change the version number so that the participants who see this new configuration file can be identified.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class UIConfig(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    autoDownloadStudy: Optional[bool] = Field(
        None,
        description='Controls whether the study data is automatically downloaded at the end of the study.',
    )
    autoDownloadTime: Optional[float] = Field(
        None,
        description='The time in milliseconds to wait before automatically downloading the study data.',
    )
    contactEmail: str = Field(
        ...,
        description='The email address that used during the study if a participant clicks contact.',
    )
    enumerateQuestions: Optional[bool] = Field(
        None,
        description='Whether to prepend questions with their index (+ 1). This should only be used when all questions are in the same location, e.g. all are in the side bar.',
    )
    helpTextPath: Optional[str] = Field(
        None,
        description='The path to the help text file. This is displayed when a participant clicks help. Markdown is supported.',
    )
    logoPath: str = Field(
        ...,
        description='The path to the logo image. This is displayed on the landing page and the header.',
    )
    nextOnEnter: Optional[bool] = Field(
        None,
        description='Whether enter key should move to the next question. Defaults to false.',
    )
    numSequences: Optional[float] = Field(
        None,
        description='The number of sequences to generate for the study. This is used to generate the random sequences for the study. The default is 1000.',
    )
    participantNameField: Optional[str] = Field(
        None,
        description="The default name field for a participant. Directs revisit to use the task and response id as a name in UI elements. For example, if you wanted the response 'prolificId' from the task 'introduction' to be the name, this field would be 'introduction.prolificId'",
    )
    recordStudyAudio: Optional[bool] = Field(
        None,
        description='Whether or not we want to utilize think-aloud features. If true, will record audio on all components unless deactivated on individual components. Defaults to false.',
    )
    sidebar: bool = Field(
        ...,
        description="Controls whether the left sidebar is rendered at all. Required to be true if your response's location is set to sidebar for any question.",
    )
    sidebarWidth: Optional[float] = Field(
        None, description='The width of the left sidebar. Defaults to 300.'
    )
    studyEndMsg: Optional[str] = Field(
        None, description='The message to display when the study ends.'
    )
    timeoutReject: Optional[bool] = Field(
        None,
        description='Whether to redirect a timed out participant to a rejection page. This only works for components where the `nextButtonDisableTime` field is set.',
    )
    urlParticipantIdParam: Optional[str] = Field(
        None,
        description='If the participant ID is passed in the URL, this is the name of the querystring parameter that is used to capture the participant ID (e.g. PROLIFIC_ID). This will allow a user to continue a study on different devices and browsers.',
    )
    windowEventDebounceTime: Optional[float] = Field(
        None,
        description='Debounce time in milliseconds for automatically tracked window events. Defaults to 100. E.g 100 here means 1000ms / 100ms = 10 times a second, 200 here means 1000ms / 200ms = 5 times per second',
    )
    withProgressBar: bool = Field(
        ..., description='Controls whether the progress bar is rendered in the study.'
    )  # End of class


class UIConfigType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    autoDownloadStudy: Optional[bool] = Field(
        None,
        description='Controls whether the study data is automatically downloaded at the end of the study.',
    )
    autoDownloadTime: Optional[float] = Field(
        None,
        description='The time in milliseconds to wait before automatically downloading the study data.',
    )
    contactEmail: str = Field(
        ...,
        description='The email address that used during the study if a participant clicks contact.',
    )
    enumerateQuestions: Optional[bool] = Field(
        None,
        description='Whether to prepend questions with their index (+ 1). This should only be used when all questions are in the same location, e.g. all are in the side bar.',
    )
    helpTextPath: Optional[str] = Field(
        None,
        description='The path to the help text file. This is displayed when a participant clicks help. Markdown is supported.',
    )
    logoPath: str = Field(
        ...,
        description='The path to the logo image. This is displayed on the landing page and the header.',
    )
    nextOnEnter: Optional[bool] = Field(
        None,
        description='Whether enter key should move to the next question. Defaults to false.',
    )
    numSequences: Optional[float] = Field(
        None,
        description='The number of sequences to generate for the study. This is used to generate the random sequences for the study. The default is 1000.',
    )
    participantNameField: Optional[str] = Field(
        None,
        description="The default name field for a participant. Directs revisit to use the task and response id as a name in UI elements. For example, if you wanted the response 'prolificId' from the task 'introduction' to be the name, this field would be 'introduction.prolificId'",
    )
    recordStudyAudio: Optional[bool] = Field(
        None,
        description='Whether or not we want to utilize think-aloud features. If true, will record audio on all components unless deactivated on individual components. Defaults to false.',
    )
    sidebar: bool = Field(
        ...,
        description="Controls whether the left sidebar is rendered at all. Required to be true if your response's location is set to sidebar for any question.",
    )
    sidebarWidth: Optional[float] = Field(
        None, description='The width of the left sidebar. Defaults to 300.'
    )
    studyEndMsg: Optional[str] = Field(
        None, description='The message to display when the study ends.'
    )
    timeoutReject: Optional[bool] = Field(
        None,
        description='Whether to redirect a timed out participant to a rejection page. This only works for components where the `nextButtonDisableTime` field is set.',
    )
    urlParticipantIdParam: Optional[str] = Field(
        None,
        description='If the participant ID is passed in the URL, this is the name of the querystring parameter that is used to capture the participant ID (e.g. PROLIFIC_ID). This will allow a user to continue a study on different devices and browsers.',
    )
    windowEventDebounceTime: Optional[float] = Field(
        None,
        description='Debounce time in milliseconds for automatically tracked window events. Defaults to 100. E.g 100 here means 1000ms / 100ms = 10 times a second, 200 here means 1000ms / 200ms = 5 times per second',
    )
    withProgressBar: bool = Field(
        ..., description='Controls whether the progress bar is rendered in the study.'
    )


warnings.filterwarnings("ignore", module="pydantic")


class CheckboxResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    horizontal: Optional[bool] = Field(
        None,
        description='Whether to render the checkboxes horizontally. Defaults to false, so they render horizontally.',
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    maxSelections: Optional[float] = Field(
        None, description='The maximum number of selections that are required.'
    )
    minSelections: Optional[float] = Field(
        None, description='The minimum number of selections that are required.'
    )
    options: List[Union[StringOption, str]] = Field(
        ...,
        description='The options that are displayed as checkboxes, provided as an array of objects, with label and value fields.',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['checkbox']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )
    withOther: Optional[bool] = Field(
        None, description='Whether to render the checkboxes with an "other" option.'
    )  # End of class


class CheckboxResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    horizontal: Optional[bool] = Field(
        None,
        description='Whether to render the checkboxes horizontally. Defaults to false, so they render horizontally.',
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    maxSelections: Optional[float] = Field(
        None, description='The maximum number of selections that are required.'
    )
    minSelections: Optional[float] = Field(
        None, description='The minimum number of selections that are required.'
    )
    options: List[Union[StringOption, str]] = Field(
        ...,
        description='The options that are displayed as checkboxes, provided as an array of objects, with label and value fields.',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['checkbox']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )
    withOther: Optional[bool] = Field(
        None, description='Whether to render the checkboxes with an "other" option.'
    )


warnings.filterwarnings("ignore", module="pydantic")


class DropdownResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    options: List[Union[StringOption, str]] = Field(
        ..., description='The options that are displayed in the dropdown.'
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    placeholder: Optional[str] = Field(
        None, description='The placeholder text that is displayed in the input.'
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['dropdown']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )  # End of class


class DropdownResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    options: List[Union[StringOption, str]] = Field(
        ..., description='The options that are displayed in the dropdown.'
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    placeholder: Optional[str] = Field(
        None, description='The placeholder text that is displayed in the input.'
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['dropdown']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )


class InterruptionBlock(
    RootModel[Union[DeterministicInterruption, RandomInterruption]]
):
    root: Union[DeterministicInterruption, RandomInterruption] = Field(
        ...,
        description='The InterruptionBlock interface is used to define interruptions in a block. These can be used for breaks or attention checks. Interruptions can be deterministic or random.',
    )


# End of class


class InterruptionBlockType(TypedDict):
    root: Union[DeterministicInterruption, RandomInterruption] = Field(
        ...,
        description='The InterruptionBlock interface is used to define interruptions in a block. These can be used for breaks or attention checks. Interruptions can be deterministic or random.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class LikertResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    leftLabel: Optional[str] = Field(
        None, description='The left label of the likert scale. E.g Strongly Disagree'
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    numItems: float = Field(..., description='The number of options to render.')
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    rightLabel: Optional[str] = Field(
        None, description='The right label of the likert scale. E.g Strongly Agree'
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['likert']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )  # End of class


class LikertResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    leftLabel: Optional[str] = Field(
        None, description='The left label of the likert scale. E.g Strongly Disagree'
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    numItems: float = Field(..., description='The number of options to render.')
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    rightLabel: Optional[str] = Field(
        None, description='The right label of the likert scale. E.g Strongly Agree'
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['likert']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class LongTextResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    placeholder: Optional[str] = Field(
        None, description='The placeholder text that is displayed in the input.'
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['longText']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )  # End of class


class LongTextResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    placeholder: Optional[str] = Field(
        None, description='The placeholder text that is displayed in the input.'
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['longText']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class MatrixResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    answerOptions: Union[List[str], str] = Field(
        ...,
        description='The answer options (columns). We provide some shortcuts for a likelihood scale (ranging from highly unlikely to highly likely) and a satisfaction scale (ranging from highly unsatisfied to highly satisfied) with either 5 or 7 options to choose from.',
    )
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    questionOptions: List[str] = Field(
        ...,
        description="The question options (rows) are the prompts for each response you'd like to record.",
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Type2
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )  # End of class


class MatrixResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    answerOptions: Union[List[str], str] = Field(
        ...,
        description='The answer options (columns). We provide some shortcuts for a likelihood scale (ranging from highly unlikely to highly likely) and a satisfaction scale (ranging from highly unsatisfied to highly satisfied) with either 5 or 7 options to choose from.',
    )
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    questionOptions: List[str] = Field(
        ...,
        description="The question options (rows) are the prompts for each response you'd like to record.",
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Type2
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class NumericalResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    max: Optional[float] = Field(
        None, description='The maximum value that is accepted in the input.'
    )
    min: Optional[float] = Field(
        None, description='The minimum value that is accepted in the input.'
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    placeholder: Optional[str] = Field(
        None, description='The placeholder text that is displayed in the input.'
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['numerical']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )  # End of class


class NumericalResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    max: Optional[float] = Field(
        None, description='The maximum value that is accepted in the input.'
    )
    min: Optional[float] = Field(
        None, description='The minimum value that is accepted in the input.'
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    placeholder: Optional[str] = Field(
        None, description='The placeholder text that is displayed in the input.'
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['numerical']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )


warnings.filterwarnings("ignore", module="pydantic")


class RadioResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    horizontal: Optional[bool] = Field(
        None,
        description='Whether to render the radio buttons horizontally. Defaults to false, so they render horizontally.',
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    leftLabel: Optional[str] = Field(
        None,
        description='The left label of the radio group. Used in Likert scales for example',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    options: List[Union[StringOption, str]] = Field(
        ...,
        description='The options that are displayed as checkboxes, provided as an array of objects, with label and value fields.',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    rightLabel: Optional[str] = Field(
        None,
        description='The right label of the radio group. Used in Likert scales for example',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['radio']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )
    withOther: Optional[bool] = Field(
        None, description='Whether to render the radios with an "other" option.'
    )  # End of class


class RadioResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    horizontal: Optional[bool] = Field(
        None,
        description='Whether to render the radio buttons horizontally. Defaults to false, so they render horizontally.',
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    leftLabel: Optional[str] = Field(
        None,
        description='The left label of the radio group. Used in Likert scales for example',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    options: List[Union[StringOption, str]] = Field(
        ...,
        description='The options that are displayed as checkboxes, provided as an array of objects, with label and value fields.',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    rightLabel: Optional[str] = Field(
        None,
        description='The right label of the radio group. Used in Likert scales for example',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['radio']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )
    withOther: Optional[bool] = Field(
        None, description='Whether to render the radios with an "other" option.'
    )


warnings.filterwarnings("ignore", module="pydantic")


class ReactiveResponse(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['reactive']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )  # End of class


class ReactiveResponseType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    hidden: Optional[bool] = Field(
        None, description='Controls whether the response is hidden.'
    )
    id: str = Field(
        ...,
        description='The id of the response. This is used to identify the response in the data file.',
    )
    location: Optional[ResponseBlockLocation] = Field(
        None,
        description='Controls the response location. These might be the same for all responses, or differ across responses. Defaults to `belowStimulus`',
    )
    paramCapture: Optional[str] = Field(
        None,
        description='Use to capture querystring parameters in answers such as participant_name. See the examples for how this is used, but prefer uiConfig.urlParticipantIdParam if you are capturing a participant ID.',
    )
    prompt: str = Field(
        ...,
        description='The prompt that is displayed to the participant. You can use markdown here to render images, links, etc.',
    )
    required: Optional[bool] = Field(
        None,
        description='Controls whether the response is required to be answered. Defaults to true.',
    )
    requiredLabel: Optional[str] = Field(
        None,
        description='You can provide a required label, which makes it so a participant has to answer with a response that matches label.',
    )
    requiredValue: Optional[Any] = Field(
        None,
        description='You can provide a required value, which makes it so a participant has to answer with that value.',
    )
    secondaryText: Optional[str] = Field(
        None,
        description='The secondary text that is displayed to the participant under the prompt. This does not accept markdown.',
    )
    type: Literal['reactive']
    withDivider: Optional[bool] = Field(
        None, description='Renders the response with a trailing divider.'
    )
    withDontKnow: Optional[bool] = Field(
        None,
        description='Renders the response with an option for "I don\'t know". This counts as a completed answer for the validation.',
    )


class Response(
    RootModel[
        Union[
            NumericalResponse,
            ShortTextResponse,
            LongTextResponse,
            LikertResponse,
            DropdownResponse,
            SliderResponse,
            RadioResponse,
            CheckboxResponse,
            ReactiveResponse,
            MatrixResponse,
        ]
    ]
):
    root: Union[
        NumericalResponse,
        ShortTextResponse,
        LongTextResponse,
        LikertResponse,
        DropdownResponse,
        SliderResponse,
        RadioResponse,
        CheckboxResponse,
        ReactiveResponse,
        MatrixResponse,
    ]


# End of class


class ResponseType(TypedDict):
    root: Union[
        NumericalResponse,
        ShortTextResponse,
        LongTextResponse,
        LikertResponse,
        DropdownResponse,
        SliderResponse,
        RadioResponse,
        CheckboxResponse,
        ReactiveResponse,
        MatrixResponse,
    ]


warnings.filterwarnings("ignore", module="pydantic")


class VegaComponentConfig(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    config: Dict[str, Any] = Field(
        ..., description='The vega or vega-lite configuration.'
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['vega']  # End of class


class VegaComponentConfigType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    config: Dict[str, Any] = Field(
        ..., description='The vega or vega-lite configuration.'
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['vega']


warnings.filterwarnings("ignore", module="pydantic")


class VegaComponentPath(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    path: str = Field(
        ...,
        description='The path to the vega file. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['vega']  # End of class


class VegaComponentPathType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    path: str = Field(
        ...,
        description='The path to the vega file. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['vega']


warnings.filterwarnings("ignore", module="pydantic")


class WebsiteComponent(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description='The parameters that are passed to the website (iframe). These can be used within your website to render different things.',
    )
    path: str = Field(
        ...,
        description='The path to the website. This should be a relative path from the public folder or could be an external website.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['website']  # End of class


class WebsiteComponentType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description='The parameters that are passed to the website (iframe). These can be used within your website to render different things.',
    )
    path: str = Field(
        ...,
        description='The path to the website. This should be a relative path from the public folder or could be an external website.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['website']


warnings.filterwarnings("ignore", module="pydantic")


class BaseComponents1(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    config: Optional[Dict[str, Any]] = Field(
        None, description='The vega or vega-lite configuration.'
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description='The parameters that are passed to the react component. These can be used within your react component to render different things.',
    )
    path: Optional[str] = Field(
        None,
        description='The path to the markdown file. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: Optional[List[Response]] = Field(
        None, description='The responses to the component'
    )
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    style: Optional[Dict[str, str]] = Field(
        None,
        description='The style of the image. This is an object with css properties as keys and css values as values.',
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Optional[Type] = None  # End of class


class BaseComponents1Type(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    config: Optional[Dict[str, Any]] = Field(
        None, description='The vega or vega-lite configuration.'
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description='The parameters that are passed to the react component. These can be used within your react component to render different things.',
    )
    path: Optional[str] = Field(
        None,
        description='The path to the markdown file. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: Optional[List[Response]] = Field(
        None, description='The responses to the component'
    )
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    style: Optional[Dict[str, str]] = Field(
        None,
        description='The style of the image. This is an object with css properties as keys and css values as values.',
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Optional[Type] = None


class BaseComponents(RootModel[Optional[Dict[str, BaseComponents1]]]):
    root: Optional[Dict[str, BaseComponents1]] = None


# End of class


class BaseComponentsType(TypedDict):
    root: Optional[Dict[str, BaseComponents1]] = None


warnings.filterwarnings("ignore", module="pydantic")


class ComponentBlock(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    components: List[Union[str, ComponentBlock]] = Field(
        ..., description='The components that are included in the order.'
    )
    id: Optional[str] = Field(
        None,
        description='The id of the block. This is used to identify the block in the SkipConditions and is only required if you want to refer to the whole block in the condition.to property.',
    )
    interruptions: Optional[List[InterruptionBlock]] = Field(
        None,
        description='The interruptions property specifies an array of interruptions. These can be used for breaks or attention checks.',
    )
    numSamples: Optional[float] = Field(
        None,
        description='The number of samples to use for the random assignments. This means you can randomize across 3 components while only showing a participant 2 at a time.',
    )
    order: Order = Field(
        ...,
        description='The type of order. This can be random (pure random), latinSquare (random with some guarantees), or fixed.',
    )
    skip: Optional[SkipConditions] = Field(
        None, description='The skip conditions for the block.'
    )  # End of class


class ComponentBlockType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    components: List[Union[str, ComponentBlock]] = Field(
        ..., description='The components that are included in the order.'
    )
    id: Optional[str] = Field(
        None,
        description='The id of the block. This is used to identify the block in the SkipConditions and is only required if you want to refer to the whole block in the condition.to property.',
    )
    interruptions: Optional[List[InterruptionBlock]] = Field(
        None,
        description='The interruptions property specifies an array of interruptions. These can be used for breaks or attention checks.',
    )
    numSamples: Optional[float] = Field(
        None,
        description='The number of samples to use for the random assignments. This means you can randomize across 3 components while only showing a participant 2 at a time.',
    )
    order: Order = Field(
        ...,
        description='The type of order. This can be random (pure random), latinSquare (random with some guarantees), or fixed.',
    )
    skip: Optional[SkipConditions] = Field(
        None, description='The skip conditions for the block.'
    )


warnings.filterwarnings("ignore", module="pydantic")


class ImageComponent(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    path: str = Field(
        ...,
        description='The path to the image. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    style: Optional[Dict[str, str]] = Field(
        None,
        description='The style of the image. This is an object with css properties as keys and css values as values.',
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['image']  # End of class


class ImageComponentType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    path: str = Field(
        ...,
        description='The path to the image. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    style: Optional[Dict[str, str]] = Field(
        None,
        description='The style of the image. This is an object with css properties as keys and css values as values.',
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['image']


warnings.filterwarnings("ignore", module="pydantic")


class InheritedComponent(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    baseComponent: str
    config: Optional[Dict[str, Any]] = Field(
        None, description='The vega or vega-lite configuration.'
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description='The parameters that are passed to the react component. These can be used within your react component to render different things.',
    )
    path: Optional[str] = Field(
        None,
        description='The path to the markdown file. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: Optional[List[Response]] = Field(
        None, description='The responses to the component'
    )
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    style: Optional[Dict[str, str]] = Field(
        None,
        description='The style of the image. This is an object with css properties as keys and css values as values.',
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Optional[Type] = None  # End of class


class InheritedComponentType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    baseComponent: str
    config: Optional[Dict[str, Any]] = Field(
        None, description='The vega or vega-lite configuration.'
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description='The parameters that are passed to the react component. These can be used within your react component to render different things.',
    )
    path: Optional[str] = Field(
        None,
        description='The path to the markdown file. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: Optional[List[Response]] = Field(
        None, description='The responses to the component'
    )
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    style: Optional[Dict[str, str]] = Field(
        None,
        description='The style of the image. This is an object with css properties as keys and css values as values.',
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Optional[Type] = None


warnings.filterwarnings("ignore", module="pydantic")


class MarkdownComponent(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    path: str = Field(
        ...,
        description='The path to the markdown file. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['markdown']  # End of class


class MarkdownComponentType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    path: str = Field(
        ...,
        description='The path to the markdown file. This should be a relative path from the public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['markdown']


warnings.filterwarnings("ignore", module="pydantic")


class QuestionnaireComponent(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['questionnaire']  # End of class


class QuestionnaireComponentType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['questionnaire']


warnings.filterwarnings("ignore", module="pydantic")


class ReactComponent(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description='The parameters that are passed to the react component. These can be used within your react component to render different things.',
    )
    path: str = Field(
        ...,
        description='The path to the react component. This should be a relative path from the src/public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['react-component']  # End of class


class ReactComponentType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    allowFailedTraining: Optional[bool] = Field(
        None,
        description='Controls whether the component should allow failed training. If not provided, the default is true.',
    )
    correctAnswer: Optional[List[Answer]] = Field(
        None,
        description='The correct answer to the component. This is used for training trials where the user is shown the correct answer after a guess.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instruction: Optional[str] = Field(
        None,
        description='The instruction of the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    instructionLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the instructions.'
    )
    meta: Optional[Dict[str, Any]] = Field(
        None,
        description='The meta data for the component. This is used to identify and provide additional information for the component in the admin panel.',
    )
    nextButtonDisableTime: Optional[float] = Field(
        None,
        description='A timeout (in ms) after which the next button will be disabled.',
    )
    nextButtonEnableTime: Optional[float] = Field(
        None, description='A timer (in ms) after which the next button will be enabled.'
    )
    nextButtonLocation: Optional[ResponseBlockLocation] = Field(
        None, description='The location of the next button.'
    )
    nextButtonText: Optional[str] = Field(
        None, description='The text that is displayed on the next button.'
    )
    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description='The parameters that are passed to the react component. These can be used within your react component to render different things.',
    )
    path: str = Field(
        ...,
        description='The path to the react component. This should be a relative path from the src/public folder.',
    )
    provideFeedback: Optional[bool] = Field(
        None,
        description='Controls whether the component should provide feedback to the participant, such as in a training trial. If not provided, the default is false.',
    )
    recordAudio: Optional[bool] = Field(
        None,
        description='Whether or not to record audio for a component. Only relevant if recordStudyAudio in the uiConfig is true. Defaults to false.',
    )
    response: List[Response] = Field(..., description='The responses to the component')
    responseDividers: Optional[bool] = Field(
        None, description='Whether to show the response dividers. Defaults to false.'
    )
    trainingAttempts: Optional[float] = Field(
        None,
        description='The number of training attempts allowed for the component. The next button will be disabled until either the correct answer is given or the number of attempts is reached. When the number of attempts is reached, if the answer is incorrect still, the correct value will be shown to the participant. The default value is 2. Providing a value of -1 will allow infinite attempts and the participant must enter the correct answer to continue, and reVISit will not show the correct answer to the user.',
    )
    type: Literal['react-component']


class VegaComponent(RootModel[Union[VegaComponentPath, VegaComponentConfig]]):
    root: Union[VegaComponentPath, VegaComponentConfig]


# End of class


class VegaComponentType(TypedDict):
    root: Union[VegaComponentPath, VegaComponentConfig]


class IndividualComponent(
    RootModel[
        Union[
            MarkdownComponent,
            ReactComponent,
            ImageComponent,
            WebsiteComponent,
            QuestionnaireComponent,
            VegaComponent,
        ]
    ]
):
    root: Union[
        MarkdownComponent,
        ReactComponent,
        ImageComponent,
        WebsiteComponent,
        QuestionnaireComponent,
        VegaComponent,
    ]


# End of class


class IndividualComponentType(TypedDict):
    root: Union[
        MarkdownComponent,
        ReactComponent,
        ImageComponent,
        WebsiteComponent,
        QuestionnaireComponent,
        VegaComponent,
    ]


warnings.filterwarnings("ignore", module="pydantic")


class StudyConfig(BaseModel):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    schema: str = Field(
        ...,
        alias='$schema',
        description="A required json schema property. This should point to the github link for the version of the schema you would like. The `$schema` line is used to verify the schema. If you're using VSCode (or other similar IDEs), including this line will allow for autocomplete and helpful suggestions when writing the study configuration. See examples for more information",
    )
    baseComponents: Optional[BaseComponents] = Field(
        None,
        description='The base components that are used in the study. These components can be used to template other components. See [BaseComponents](../../type-aliases/BaseComponents) for more information.',
    )
    components: Dict[str, Union[IndividualComponent, InheritedComponent]] = Field(
        ...,
        description='The components that are used in the study. They must be fully defined here with all properties. Some properties may be inherited from baseComponents.',
    )
    importedLibraries: Optional[List[str]] = Field(
        None,
        description='A list of libraries that are used in the study. This is used to import external libraries into the study. Library names are valid namespaces to be used later.',
    )
    sequence: ComponentBlock = Field(
        ...,
        description='The order of the components in the study. This might include some randomness.',
    )
    studyMetadata: StudyMetadata = Field(
        ...,
        description='The metadata for the study. This is used to identify the study and version in the data file.',
    )
    uiConfig: UIConfig = Field(
        ...,
        description='The UI configuration for the study. This is used to configure the UI of the app.',
    )  # End of class


class StudyConfigType(TypedDict):
    model_config = ConfigDict(extra='forbid', populate_by_name=True)
    schema: str = Field(
        ...,
        alias='$schema',
        description="A required json schema property. This should point to the github link for the version of the schema you would like. The `$schema` line is used to verify the schema. If you're using VSCode (or other similar IDEs), including this line will allow for autocomplete and helpful suggestions when writing the study configuration. See examples for more information",
    )
    baseComponents: Optional[BaseComponents] = Field(
        None,
        description='The base components that are used in the study. These components can be used to template other components. See [BaseComponents](../../type-aliases/BaseComponents) for more information.',
    )
    components: Dict[str, Union[IndividualComponent, InheritedComponent]] = Field(
        ...,
        description='The components that are used in the study. They must be fully defined here with all properties. Some properties may be inherited from baseComponents.',
    )
    importedLibraries: Optional[List[str]] = Field(
        None,
        description='A list of libraries that are used in the study. This is used to import external libraries into the study. Library names are valid namespaces to be used later.',
    )
    sequence: ComponentBlock = Field(
        ...,
        description='The order of the components in the study. This might include some randomness.',
    )
    studyMetadata: StudyMetadata = Field(
        ...,
        description='The metadata for the study. This is used to identify the study and version in the data file.',
    )
    uiConfig: UIConfig = Field(
        ...,
        description='The UI configuration for the study. This is used to configure the UI of the app.',
    )


class Model(RootModel[StudyConfig]):
    root: StudyConfig


# End of class


class ModelType(TypedDict):
    root: StudyConfig


ComponentBlock.model_rebuild()
